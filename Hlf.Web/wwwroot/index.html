<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HLF-Transpiler</title>
    <script src="./node_modules/monaco-editor/min/vs/loader.js"></script>
    <script>
        
        function getMonarchDef(){
            return {
                // Set defaultToken to invalid to see what you do not tokenize yet
                defaultToken: 'invalid',

                keywords: [
                    "if", "while", "for", "else", "val", "var", "break"
                ],

                typeKeywords: [
                    "string", "int", "float", "bool", "Entity", "Vector", "BlockType", "void"
                ],

                operators: [
                    "==", '*', '+', '-', '/'
                ],

                // we include these common regular expressions
                symbols:  /[=><!~?:&|+\-*\/\^%]+/,

                // C# style strings
                escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,

                // The main tokenizer for our languages
                tokenizer: {
                    root:[
                        { include:'@rootWithoutCustomTypes' },

                        // custom types
                        [/(?<!\.)[A-Z][\w\$]*/, 'type.identifier']  // to show class names nicely
                    ],
                    rootWithoutCustomTypes: [
                        // identifiers and keywords
                        [/[a-z_][\w$]*(?=\()/, { cases: {
                                '@keywords': 'keyword',
                                '@default': 'function'
                            }
                        }],
                        [/[a-z_][\w$]*/, { cases: {
                                '@typeKeywords': 'keyword',
                                '@keywords': 'keyword',
                                '@default': 'identifier' } }],

                        [/[A-Z]\w+/, {
                            cases: {'@typeKeywords': 'type.keyword', '@default': 'identifier'}
                        }],

                        // whitespace
                        { include: '@whitespace' },

                        // selector
                        [/@[aenprs](?:\[.*])?/, 'attribute.value'],

                        // delimiters and operators
                        [/}/, {
                            cases: {
                                '$S2==interpolatedstring': { token: 'string.quote', next: '@pop' },
                                '@default': '@brackets'
                            }
                        }],
                        [/[{()\[\]]/, '@brackets'],
                        [/[<>](?!@symbols)/, '@brackets'],
                        [/@symbols/, { cases: { '@operators': 'operator',
                                '@default'  : '' } } ],

                        // numbers
                        [/-?(?:(\.\d+|\d+\.\d+)[fFdD]?|(\d+)[fFdD])/, 'number.float'],
                        [/-?\d+/, 'number'],

                        // delimiter: after number because of .\d floats
                        [/[;,]/, 'delimiter'],
                        [/\./, 'delimiter', '@rootWithoutCustomTypes'],

                        // strings
                        [/\$"/, { token: 'string.quote', next: '@interpolatedstring' }],
                        [/"([^"\\]|\\.)*$/, 'string.invalid' ],  // non-teminated string
                        [/"/,  { token: 'string.quote', bracket: '@open', next: '@string' } ],
                    ],

                    comment: [
                        [/[^\/*]+/, 'comment' ],
                        [/\/\*/,    'comment', '@push' ],    // nested comment
                        ["\\*/",    'comment', '@pop'  ],
                        [/[\/*]/,   'comment' ]
                    ],

                    string: [
                        [/[^\\"]+/,  'string'],
                        [/@escapes/, 'string.escape'],
                        [/\\./,      'string.escape.invalid'],
                        [/"/,        { token: 'string.quote', bracket: '@close', next: '@pop' } ]
                    ],

                    interpolatedstring: [
                        [/[^\\"{]+/, 'string'],
                        //[/@escapes/, 'string.escape'],
                        [/\\./, 'string.escape.invalid'],
                        //[/{{/, 'string.escape'],
                        //[/}}/, 'string.escape'],
                        [/{/, { token: 'string.quote', next: 'root.interpolatedstring' }],
                        [/"/, { token: 'string.quote', next: '@pop' }]
                    ],

                    whitespace: [
                        [/[ \t\r\n]+/, 'white'],
                        [/\/\*/,       'comment', '@comment' ],
                        [/\/\/.*$/,    'comment'],
                        [/\/#.*$/,    'comment'],
                    ],
                },
            };
        }
        
        require.config({ paths: { vs: 'node_modules/monaco-editor/min/vs' } });
        require(["vs/editor/editor.main"], () => {
            monaco.languages.register({ id: "hlf" });
            document.editorModel = monaco.editor.createModel(`

Entity player = @p;
val radius = 4;
void tick(){
    val belowPlayer = player.Position;
    for(int x = -1*radius; x < radius;x++){
        for(int z = -1*radius; z < radius; z++){
            say($"Calculating for block ({x}; {z})");
            val v = belowPlayer+Vector(x, -1, z);
            if(x*x + z*z < 5){
                if(getBlock(v) == BlockType("water")){
                    setBlock(v, BlockType("ice"));
                }
            }
        }
    }
}
`,
                "hlf"
            );

            monaco.editor.defineTheme("hlf-vs-dark", {
                base: "vs-dark",
                inherit: true,
                colors: {},
                rules: [
                    { token: "function", foreground: "39CC8F" },
                ],
            });
            
            document.codeEditor = monaco.editor.create(document.getElementById('codeContainer'), {
                theme: 'hlf-vs-dark',
                tabSize: 4,
                directIndentation: true,
                useTabStops: true,
                model: document.editorModel,
                autoClosingBrackets: true,
                automaticLayout: true,
                mouseWheelZoom: true
            });

            document.codeEditor.addAction(
                {
                    id:"transpile",
                    label:"Transpile to mcfunction",
                    run: function(){
                        window.transpile(false)
                    }
                }
            );
            
            // I add vs keybindings first and then the default vscode ones so that the vscode ones are displayed but mine are still usable
            monaco.editor.addKeybindingRules([
                {
                    keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyMod.Alt | monaco.KeyCode.NumpadDivide,
                    command: "editor.action.commentLine",
                    when: "textInputFocus",
                },
                {
                    keybinding: monaco.KeyMod.CtrlCmd  | monaco.KeyCode.Slash,
                        command: "editor.action.commentLine",
                    when: "textInputFocus",
                },
                {
                    keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.NumpadDivide,
                    command: "editor.action.blockComment",
                    when: "textInputFocus",
                },
                {
                    keybinding: monaco.KeyMod.Shift | monaco.KeyMod.Alt | monaco.KeyCode.KeyA,
                        command: "editor.action.blockComment",
                    when: "textInputFocus",
                }
            ]);

            monaco.languages.setMonarchTokensProvider("hlf", getMonarchDef());
            monaco.languages.setLanguageConfiguration('hlf', {
                brackets: [
                    ['{', '}'],
                    ['[', ']'],
                    ['(', ')']
                ],
                autoClosingPairs: [
                    { open: '{', close: '}', notIn: ['string', 'comment'] },
                    { open: '[', close: ']', notIn: ['string', 'comment'] },
                    { open: '(', close: ')', notIn: ['string', 'comment'] },
                    { open: '"', close: '"', notIn: ['string'] },
                ],
                surroundingPairs: [
                    { open: '{', close: '}' },
                    { open: '[', close: ']' },
                    { open: '(', close: ')' },
                    { open: '"', close: '"' },
                ],
                comments: {
                    blockComment: ["/*", "*/"],
                    lineComment: "//",
                }
            });
            
            monaco.languages.registerHoverProvider("hlf", {
                provideHover: function (model, position) {
                    let word = model.getWordAtPosition(position)
                    if(word === null) return
                    let afterWord = model.getValueInRange(new monaco.Range(position.lineNumber, word.endColumn, position.lineNumber, word.endColumn+1));
                    if(afterWord !== '(') return
                    
                    let data = window.getFunctionData(word.word);
                    if(!data.success) return

                    return {
                        range: new monaco.Range(
                            position.lineNumber,
                            word.startColumn,
                            position.lineNumber,
                            word.endColumn,
                        ),
                        contents: [
                            {
                                value: data.description
                            },
                            {
                                value: "**Overloads:**"
                            },
                            {
                                 value: data.overloads.map(function (str) {
                                    return "- " + str + "\n"
                                }).join('\n')
                            },
                        ],
                    };
                },
            });
            document.editorModel.onDidChangeContent(autoRetranspile);
            console.log("Initial transpile from editor")
            window.transpile()
        });
    </script>
    
    <script>
        // https://stackoverflow.com/a/30810322
        function fallbackCopyTextToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.value = text;

            // Avoid scrolling to bottom
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                var successful = document.execCommand('copy');
                var msg = successful ? 'successful' : 'unsuccessful';
                console.log('Fallback: Copying text command was ' + msg);
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }

            document.body.removeChild(textArea);
        }
        function copyOutputToClipboard() {
            const text = document.getElementById("outputTextArea").value;
            console.log("copying: " + text);
            if (!navigator.clipboard) {
                fallbackCopyTextToClipboard(text);
                return;
            }
            navigator.clipboard.writeText(text).then(function() {
                console.log('Async: Copying to clipboard was successful!');
            }, function(err) {
                console.error('Async: Could not copy text: ', err);
            });
        }
        
        function switchFile(){
            let file = document.getElementById("file-view-select").value;
            console.log("Switching to file " + file);
            let outputWindow = document.getElementById("outputTextArea");
            outputWindow.value = document.transpiledJson[file];
        }
        
        async function openLocalDir(){

            if(!('showOpenFilePicker' in window)){
                alert("Your browser currently does not support FileSystemAccessAPI which is needed for modifying local files. Try using a chromium-based browser");
                return;
            }
            
            document.dirHandle = await window.showDirectoryPicker();
            console.log("got file handle: " + document.dirHandle);
            document.getElementById("saveInRealtimeCheckbox").disabled = false;
            document.getElementById("workInLocalDirButton").innerText = "Change working directory";
        }
        
        async function saveDatapackLocally(){
            let json = document.transpiledJson;
            
            for(const o in json){

                let subdirs = o.split("/");
                let fileName = subdirs.pop()
                console.log("Creating subdirs:" + subdirs)
                // Iterate over the subdirectory names and create them
                let currentDir = document.dirHandle;
                for (const subdir of subdirs) {
                    currentDir = await currentDir.getDirectoryHandle(subdir, { create: true });
                }
                /*
                const index = o.lastIndexOf('/');
                const path = o.substring(0, index+1);
                const name = o.substring(index);
                console.log("Full path:" + o + " Location: " + path)*/
/*                let subDirHandle = document.dirHandle;
                if(path !== ""){
                    subDirHandle = await document.dirHandle.getDirectoryHandle(path, { create: true });
                }*/
                const fileHandle = await currentDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(json[o]);
                await writable.close();
            }
        }
        
        function autoRetranspile(){
            if(document.getElementById("transpileInRealtimeCheckbox").checked){
                window.transpile(true);
            }        
        }
        
    </script>
    <script lang="js" type="module">
        // Importing compiled ES module.
        import bootsharp, {HlfTranspilerJs} from "./../bin/bootsharp/index.mjs";
        //import bootsharp, {HlfTranspilerJs} from "./index.mjs";

        // Initializing dotnet runtime and invoking entry point.

        const wasmWorker = new Worker("worker.js", {type:"module"});
        
        wasmWorker.onmessage = (e) => {
            if(e.data === 0){
                // worker is ready!
                console.log("Initial transpile from editor")
                window.transpile()
                if(document.getElementById("useWorkerCheckbox").checked) document.getElementById("transpileButton").disabled = false;
                return;
            }
            onResult(e.data)
        };
        let isAuto = false;
        
        window.getFunctionData = HlfTranspilerJs.getFunctionDescription;
        
        function getTargetVersion(){
            const strVal = document.getElementById("targetMcVersion").value;
            const parts = strVal.split('.');
            if(parts.length === 3){
                return {
                    Major: +parts[0],
                    Minor: +parts[1],
                    Patch: +parts[2],
                }
            }
            return {
                Major: +parts[0],
                Minor: +parts[1],
                Patch: 0,
            }
        }
        export function transpile(isAuto = false){
            
            isAuto = isAuto;
            let options = {
                GenerateComments: document.getElementById("generateComments").checked,
                TargetVersion: getTargetVersion()
            }
            
            window.TranspileStart = performance.now()
            if(document.getElementById("useWorkerCheckbox").checked)
                wasmWorker.postMessage(
                        [document.editorModel.getValue(), options]);
            else{
                const resp = HlfTranspilerJs.transpileToString(document.editorModel.getValue(), options);
                onResult(resp);
            }
        }
        
        function onResult(resp){
            const ms = (performance.now()-window.TranspileStart);
            document.getElementById("stats").innerText = `${ms.toFixed(1)}ms (${(1/ms*1000).toFixed(0)}hz)`;

            const msgField = document.getElementById("errorMsg");
            const successField = document.getElementById("successMsg");
            if(resp.startsWith("errhndl(")){

                const metaStart = resp.indexOf('(');
                const metaEnd = resp.indexOf(')');
                const nums = resp.substring(metaStart+1, metaEnd).split(';');

                const line = parseInt(nums[0]);
                const column = parseInt(nums[1]);
                const length = parseInt(nums[2]);
                console.log("line:" + line + " column:" + column + " length:" + length)


                const err = resp.substring(metaEnd+2);
                console.log("Error detected: " + err)
                msgField.style.visibility = "visible";
                msgField.innerText = err;
                successField.style.visibility = "hidden";



                // show errors:
                require(["vs/editor/editor.main"], () => {
                    monaco.editor.setModelMarkers(document.editorModel, "owner", [
                        {
                            startLineNumber: line,
                            startColumn: column,
                            endLineNumber: line,
                            endColumn: column+length,
                            message: err,
                            severity: monaco.MarkerSeverity.Error
                        }
                    ]);
                });
                return;
            }
            // clear errors in editor:
            require(["vs/editor/editor.main"], () => {
                monaco.editor.setModelMarkers(document.editorModel, "owner", []);
            });


            msgField.style.visibility = "hidden";
            successField.style.visibility = "visible";

            let json = JSON.parse(resp);
            //document.getElementById("outputTextArea").value = json["data/function/load.mcfunction"];
            document.transpiledJson = json;

            let oldSelectedFile = document.getElementById("file-view-select").value;
            const dropdown = document.getElementById("file-view-select");
            dropdown.innerHTML = "";
            for (let f in json){
                let option = new Option(f, f);
                option.innerText = f;
                dropdown.appendChild(option);
            }

            if(json[oldSelectedFile] !== undefined){
                dropdown.value = oldSelectedFile;
            }else{
                // By default, select the load.mcfunction file
                for(let o in json){
                    if(o.endsWith("load.mcfunction")){
                        dropdown.value = o;
                        break;
                    }
                }
            }
            switchFile();

            if(document.dirHandle !== undefined && (!isAuto || document.getElementById("saveInRealtimeCheckbox").checked)){
                saveDatapackLocally();
            }
        }
        
        window.transpile = transpile;
        console.log("set window.transpile")

        /*        srcTextArea.addEventListener('input', function() {
                    if(document.getElementById("transpileInRealtimeCheckbox").checked){
                        transpile(true);
                    }
                }, false);*/
        document.getElementById("transpileButton").onclick = transpile;
        await bootsharp.boot();
        console.log(document.readyState)
        if(!document.getElementById("useWorkerCheckbox").checked) document.getElementById("transpileButton").disabled = false;
        
        window.definitions = HlfTranspilerJs.getAllBuiltinFunctionDefinitions
        
        /*
        console.log("Transpiling initially...")
        transpile(true)
        */
        //document.addEventListener('DOMContentLoaded', function (){
            const definitions = window.definitions()
            console.log("Found " + definitions.length + " definitions")
            const template = document.getElementById("template")
            for (const i in definitions) {
                const def = definitions[i]
                
                
                
                console.log(def)
                const content = template.cloneNode(true)
                document.getElementById("functionDefinitions").appendChild(content)
                content.innerHTML = content.innerHTML
                    .replace("$DESCRIPTION", def.description)
                    .replace("$NAME", def.name)
                    .replace("$OVERLOADS", def.overloads.join("<br>"))
                content.style.display = "unset";
            }
        //})
    </script>
    <script>
        // load documentation
        

        
    </script>
    
    <style>
        html{
            font-family: Arial,sans-serif;
        }
        .inputBox {
            width: 70vw;
            font-family: Consolas, "Courier New", monospace;
        }

        .output-stuff{
        }
        .outputBox {
            height: 100%;
        }
        
        button select input{
            padding: 3pt;
            border: 1px solid black;
            border-radius: 2px;
        }
    </style>
</head>
<body>
<div style="flex-direction: column">
    <div style="display: flex; flex-direction: row; height: 70vh; margin-bottom: 10pt">
        <div class="inputBox" id="codeContainer"></div>
        <div style="display: flex; flex-direction: column; width: 30vw;">
            <textarea class="outputBox output-stuff monaco-editor mtk1" id="outputTextArea" autocapitalize="off" spellcheck="false"></textarea>
            <div style="padding:3pt" class="output-stuff">
                <select id="file-view-select" style="min-width: 100pt" onchange="switchFile()">
                    <option>No files generated</option>
                </select>
                <button onclick="copyOutputToClipboard()">Copy</button>
                <button id="workInLocalDirButton" onclick="openLocalDir()">Work in local directory</button>
            </div>
        </div>
    </div>
    <div style="display: flex; flex-direction: row; gap: 15pt">
        <button id="transpileButton" style="margin-bottom: 10pt" disabled>Transpile</button>
        <span id="stats"></span>
    </div>
    <div style="background:gray; display: flex; gap:15pt; padding: 10pt">
        <div>
            <label for="transpileInRealtimeCheckbox">Transpile in realtime</label>
            <input type="checkbox" id="transpileInRealtimeCheckbox" checked onchange="autoRetranspile()">
        </div>
        <div>
            <label for="saveInRealtimeCheckbox">Save to filesystem in realtime</label>
            <input type="checkbox" id="saveInRealtimeCheckbox" disabled>
        </div>
        <div>
            <label for="useWorkerCheckbox">Use worker for transpiling</label>
            <input type="checkbox" id="useWorkerCheckbox" checked>
        </div>
        <div>
            <label for="generateComments">Generate comments</label>
            <input type="checkbox" id="generateComments" onchange="autoRetranspile()">
        </div>
        <div>
            <label for="targetMcVersion">Target Version</label>
            <select id="targetMcVersion" onchange="autoRetranspile()">
            <option selected>1.21</option>
            <option>1.20.6</option>
            <option>1.20.5</option>
            <option>1.20.4</option>
            <option>1.20.3</option>
            <option>1.20.2</option>
            <option>1.20.1</option>
            <option>1.20</option>
            <option>1.19.4</option>
            <option>1.19.3</option>
            <option>1.19.2</option>
            <option>1.19.1</option>
            <option>1.19</option>
            <option>1.18.2</option>
            <option>1.18.1</option>
            <option>1.18</option>
            <option>1.17.1</option>
            <option>1.17</option>
            <option>1.16.5</option>
            <option>1.16.4</option>
            <option>1.16.3</option>
            <option>1.16.2</option>
            <option>1.16.1</option>
            <option>1.16</option>
            <option>1.15.2</option>
            <option>1.15.1</option>
            <option>1.15</option>
            <option>1.14.4</option>
            <option>1.14.3</option>
            <option>1.14.2</option>
            <option>1.14.1</option>
            <option>1.14</option>
            <option>1.13.2</option>
            <option>1.13.1</option>
            <option>1.13</option>
        </select>
        </div>
    </div>
    <h2 style="color: red;" id="errorMsg">
        
    </h2>
    <h2 style="color: #45e445; visibility: hidden" id="successMsg">
        Transpiled successfully!
    </h2>
</div>
<div style="flex-direction: column">
    <h2>Documentation</h2>
    <li style="display: none" id="template">
        <b>$NAME()</b><br>
        <span>$DESCRIPTION</span><br>
        <b>Overloads:</b><br>
        $OVERLOADS
    </li>
    <ul id="functionDefinitions">
    </ul>
</div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HLF-Transpiler</title>
    <script src="./node_modules/monaco-editor/min/vs/loader.js"></script>
    <script>
        
        function getMonarchDef(){
            return {
                // Set defaultToken to invalid to see what you do not tokenize yet
                defaultToken: 'invalid',

                keywords: [
                    "if", "while", "for", "else", "val", "var"
                ],

                typeKeywords: [
                    "string", "int", "float", "bool", "Entity", "Vector", "BlockType", "void"
                ],

                operators: [
                    "==", '*', '+', '-', '/'
                ],

                // we include these common regular expressions
                symbols:  /[=><!~?:&|+\-*\/\^%]+/,

                // C# style strings
                escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,

                // The main tokenizer for our languages
                tokenizer: {
                    root:[
                        { include:'@rootWithoutCustomTypes' },

                        // custom types
                        [/(?<!\.)[A-Z][\w\$]*/, 'type.identifier']  // to show class names nicely
                    ],
                    rootWithoutCustomTypes: [
                        // identifiers and keywords
                        [/[a-z_$][\w$]*/, { cases: { '@typeKeywords': 'keyword',
                                '@keywords': 'keyword',
                                '@default': 'identifier' } }],

                        [/[A-Z]\w+/, {
                            cases: {'@typeKeywords': 'type.keyword', '@default': 'identifier'}
                        }],

                        // whitespace
                        { include: '@whitespace' },

                        // delimiters and operators
                        [/[{}()\[\]]/, '@brackets'],
                        [/[<>](?!@symbols)/, '@brackets'],
                        [/@symbols/, { cases: { '@operators': 'operator',
                                '@default'  : '' } } ],

                        // numbers
                        [/-?(?:\.\d+|\d+\.\d+|\d+[fFdD])/, 'number.float'],
                        [/-?\d+/, 'number'],

                        // delimiter: after number because of .\d floats
                        [/[;,]/, 'delimiter'],
                        [/\./, 'delimiter', '@rootWithoutCustomTypes'],

                        // strings
                        [/"([^"\\]|\\.)*$/, 'string.invalid' ],  // non-teminated string
                        [/"/,  { token: 'string.quote', bracket: '@open', next: '@string' } ],
                    ],

                    comment: [
                        [/[^\/*]+/, 'comment' ],
                        [/\/\*/,    'comment', '@push' ],    // nested comment
                        ["\\*/",    'comment', '@pop'  ],
                        [/[\/*]/,   'comment' ]
                    ],

                    string: [
                        [/[^\\"]+/,  'string'],
                        [/@escapes/, 'string.escape'],
                        [/\\./,      'string.escape.invalid'],
                        [/"/,        { token: 'string.quote', bracket: '@close', next: '@pop' } ]
                    ],

                    whitespace: [
                        [/[ \t\r\n]+/, 'white'],
                        [/\/\*/,       'comment', '@comment' ],
                        [/\/\/.*$/,    'comment'],
                        [/\/#.*$/,    'comment'],
                    ],
                },
            };
        }
        
        require.config({ paths: { vs: 'node_modules/monaco-editor/min/vs' } });
        require(["vs/editor/editor.main"], () => {
            monaco.languages.register({ id: "hlf" });
            document.editorModel = monaco.editor.createModel(`
killOwned();

Entity player = getEntityWithTag("player");
int c = 10;
Vector playerPos = player.Position;
BlockType block = BlockType("cyan_terracotta");

void place(){
    for(int x = -1*c; x < c; x = x+1){
        for(int y = -1*c; y < c; y = y+1){
            for(int z = -1*c; z < c; z = z+1){
                int dist_squared = x*x+y*y+z*z;
                if(dist_squared < 49){
                    Vector v = Vector(int(playerPos.x) + x, int(playerPos.y) + y, int(playerPos.z) + z);
                    setBlock(v, block);
                }
            }
        }
    }
}

void undo(){
    block = BlockType("air");
    place();
}

place();


/*
Entity player = getEntityWithTag("player");

Entity sheep = summon("sheep");
sheep.Position = Vector(-35, 63, -18);

Entity sheep2 = summon("sheep");
sheep2.Position = Vector(-33, 63, -18);

void tick()
{
    sheep.Motion = sheep2.Motion;
    //say(player.Motion);
}*/

/*
Entity sheep = getEntityWithTag("yeet");
Entity player = getEntityWithTag("player");
Vector v = player.Position;
say(v);
sheep.Motion = Vector(0, 0, 0);
*/
/*
Vector v = vec(-35, 63, -18);
BlockType block = getBlock(v);

Vector i = vec(-32, 63, -22);
setBlock(i, block);
say("Block placed!");

/# this is a comment as well!

*/
`,
                "hlf"
            );
            /*monaco.languages.setLanguageConfiguration("hlf", {
                autoClosingPairs: true,
            });*/
            document.codeEditor = monaco.editor.create(document.getElementById('codeContainer'), {
                theme: 'vs-dark',
                tabSize: 4,
                directIndentation:true,
                useTabStops:true,
                model:document.editorModel,
                autoClosingBrackets: true,
            });
            monaco.languages.setMonarchTokensProvider("hlf", getMonarchDef());
            monaco.languages.setLanguageConfiguration('hlf', {
                brackets: [
                    ['{', '}'],
                    ['[', ']'],
                    ['(', ')']
                ],
                autoClosingPairs: [
                    { open: '{', close: '}', notIn: ['string', 'comment'] },
                    { open: '[', close: ']', notIn: ['string', 'comment'] },
                    { open: '(', close: ')', notIn: ['string', 'comment'] },
                    { open: '"', close: '"', notIn: ['string'] },
                ],
                surroundingPairs: [
                    { open: '{', close: '}' },
                    { open: '[', close: ']' },
                    { open: '(', close: ')' },
                    { open: '"', close: '"' },
                ],
            });
            document.editorModel.onDidChangeContent((event) => {
                if(document.getElementById("transpileInRealtimeCheckbox").checked){
                    window.transpile(true);
                }
            });
        });
    </script>
    
    <script>
        // https://stackoverflow.com/a/30810322
        function fallbackCopyTextToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.value = text;

            // Avoid scrolling to bottom
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                var successful = document.execCommand('copy');
                var msg = successful ? 'successful' : 'unsuccessful';
                console.log('Fallback: Copying text command was ' + msg);
            } catch (err) {
                console.error('Fallback: Oops, unable to copy', err);
            }

            document.body.removeChild(textArea);
        }
        function copyOutputToClipboard() {
            const text = document.getElementById("outputTextArea").value;
            console.log("copying: " + text);
            if (!navigator.clipboard) {
                fallbackCopyTextToClipboard(text);
                return;
            }
            navigator.clipboard.writeText(text).then(function() {
                console.log('Async: Copying to clipboard was successful!');
            }, function(err) {
                console.error('Async: Could not copy text: ', err);
            });
        }
        
        function switchFile(){
            let file = document.getElementById("file-view-select").value;
            console.log("Switching to file " + file);
            let outputWindow = document.getElementById("outputTextArea");
            outputWindow.value = document.transpiledJson[file];
        }
        
        async function openLocalDir(){

            if(!('showOpenFilePicker' in window)){
                alert("Your browser currently does not support FileSystemAccessAPI which is needed for modifying local files. Try using a chromium-based browser");
                return;
            }
            
            document.dirHandle = await window.showDirectoryPicker();
            console.log("got file handle: " + document.dirHandle);
            document.getElementById("saveInRealtimeCheckbox").disabled = false;
            document.getElementById("workInLocalDirButton").innerText = "Change working directory";
        }
        
        async function saveDatapackLocally(){
            let json = document.transpiledJson;
            
            for(const o in json){

                let subdirs = o.split("/");
                let fileName = subdirs.pop()
                console.log("Creating subdirs:" + subdirs)
                // Iterate over the subdirectory names and create them
                let currentDir = document.dirHandle;
                for (const subdir of subdirs) {
                    currentDir = await currentDir.getDirectoryHandle(subdir, { create: true });
                }
                /*
                const index = o.lastIndexOf('/');
                const path = o.substring(0, index+1);
                const name = o.substring(index);
                console.log("Full path:" + o + " Location: " + path)*/
/*                let subDirHandle = document.dirHandle;
                if(path !== ""){
                    subDirHandle = await document.dirHandle.getDirectoryHandle(path, { create: true });
                }*/
                const fileHandle = await currentDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(json[o]);
                await writable.close();
            }
        }
        
    </script>
    <script lang="js" type="module">
        // Importing compiled ES module.
        import bootsharp, {HlfTranspilerJs} from "./../bin/bootsharp/index.mjs";
        //import bootsharp, {HlfTranspilerJs} from "./index.mjs";

        // Initializing dotnet runtime and invoking entry point.
        await bootsharp.boot();

        let srcTextArea = document.getElementById("hlfTextArea");
        const wasmWorker = new Worker("worker.js", {type:"module"});
        
        wasmWorker.onmessage = (e) => {
            onResult(e.data)
        };
        export function transpile(isAuto = false){
            window.TranspileStart = performance.now()
            if(document.getElementById("useWorkerCheckbox").checked)
                wasmWorker.postMessage(document.editorModel.getValue());
            else{
                const resp = HlfTranspilerJs.transpileToString(document.editorModel.getValue());
                onResult(resp);
            }
        }
        
        function onResult(resp){
            const ms = (performance.now()-window.TranspileStart);
            document.getElementById("stats").innerText = `${ms.toFixed(1)}ms (${(1/ms*1000).toFixed(0)}hz)`;

            const msgField = document.getElementById("errorMsg");
            const successField = document.getElementById("successMsg");
            if(resp.startsWith("errhndl(")){

                const metaStart = resp.indexOf('(');
                const metaEnd = resp.indexOf(')');
                const nums = resp.substring(metaStart+1, metaEnd).split(';');

                const line = parseInt(nums[0]);
                const column = parseInt(nums[1]);
                const length = parseInt(nums[2]);
                console.log("line:" + line + " column:" + column + " length:" + length)


                const err = resp.substring(metaEnd+2);
                console.log("Error detected: " + err)
                msgField.style.visibility = "visible";
                msgField.innerText = err;
                successField.style.visibility = "hidden";



                // show errors:
                require(["vs/editor/editor.main"], () => {
                    monaco.editor.setModelMarkers(document.editorModel, "owner", [
                        {
                            startLineNumber: line,
                            startColumn: column,
                            endLineNumber: line,
                            endColumn: column+length,
                            message: err,
                            severity: monaco.MarkerSeverity.Error
                        }
                    ]);
                });
                return;
            }
            // clear errors in editor:
            require(["vs/editor/editor.main"], () => {
                monaco.editor.setModelMarkers(document.editorModel, "owner", []);
            });


            msgField.style.visibility = "hidden";
            successField.style.visibility = "visible";

            let json = JSON.parse(resp);
            //document.getElementById("outputTextArea").value = json["data/function/load.mcfunction"];
            document.transpiledJson = json;

            let oldSelectedFile = document.getElementById("file-view-select").value;
            const dropdown = document.getElementById("file-view-select");
            dropdown.innerHTML = "";
            for (let f in json){
                let option = new Option(f, f);
                option.innerText = f;
                dropdown.appendChild(option);
            }

            if(json[oldSelectedFile] !== undefined){
                dropdown.value = oldSelectedFile;
            }else{
                // By default, select the load.mcfunction file
                for(let o in json){
                    if(o.endsWith("load.mcfunction")){
                        dropdown.value = o;
                        break;
                    }
                }
            }
            switchFile();

            if(document.dirHandle !== undefined && (!isAuto || document.getElementById("saveInRealtimeCheckbox").checked)){
                saveDatapackLocally();
            }
        }
        
        window.transpile = transpile;
/*        srcTextArea.addEventListener('input', function() {
            if(document.getElementById("transpileInRealtimeCheckbox").checked){
                transpile(true);
            }
        }, false);*/
        document.getElementById("transpileButton").onclick = transpile;
/*
        if(document.getElementById("hlfTextArea").value.length > 0){
            console.log("Source code area already has a value so we'll transpile right away");
            transpile(true);
        }*/
    </script>
    
    <style>
        html{
            font-family: Arial,sans-serif;
        }
        .inputBox {
            width: 70vw;
        }

        .output-stuff{
            background: cyan
        }
        .outputBox {
            height: 100%;
        }
        
        button select input{
            padding: 3pt;
            border: 1px solid black;
            border-radius: 2px;
        }
    </style>
</head>
<body>
<div style="flex-direction: column">
    <div style="display: flex; flex-direction: row; height: 70vh; margin-bottom: 10pt">
        <div class="inputBox" id="codeContainer"></div>
        <div style="display: flex; flex-direction: column; width: 30vw;">
            <textarea class="outputBox output-stuff" id="outputTextArea"></textarea>
            <div style="padding:3pt" class="output-stuff" autocapitalize="off" spellcheck="false">
                <select id="file-view-select" style="min-width: 100pt" onchange="switchFile()">
                    <option>No files generated</option>
                </select>
                <button onclick="copyOutputToClipboard()">Copy</button>
                <button id="workInLocalDirButton" onclick="openLocalDir()">Work in local directory</button>
            </div>
        </div>
    </div>
    <div style="display: flex; flex-direction: row; gap: 15pt">
        <button id="transpileButton" style="margin-bottom: 10pt">Transpile</button>
        <span id="stats"></span>
    </div>
    <div style="background:gray; display: flex; gap:15pt; padding: 10pt">
        <input type="checkbox" id="transpileInRealtimeCheckbox" checked>Transpile in realtime</input>
        <input type="checkbox" id="saveInRealtimeCheckbox" disabled>Save to filesystem in realtime</input>
        <input type="checkbox" id="useWorkerCheckbox">Use worker for transpiling</input>
    </div>
    <h2 style="color: red;" id="errorMsg">
        
    </h2>
    <h2 style="color: #45e445; visibility: hidden" id="successMsg">
        Transpiled successfully!
    </h2>
</div>
</body>
</html>
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HLF documentation HLF is a high level programming language which compiled (technically transpiled) to McFunction (Minecraft Datapacks). Here is an example script written in HLF: // The load function is ran when the datapack is loaded void load(){ say(\"let's say something 5 times:\"); for(int i = 0; i < 5; i++){ if(i == 3){ say(\"Let's just skip the 3\"); continue; } say($\"Now, we're at {i}\"); // You can use string interpolation (inserting values into strings) like this } // let's calculate some stuff say($\"2-8^2*3 = {2-pow(8, 2)*3}\"); // Swap two blocks: Vector pos1 = Vector(127, 65, 2); Vector pos2 = Vector(126, 65, 2); BlockType block1 = getBlock(pos1); BlockType block2 = getBlock(pos2); setBlock(pos1, block2); setBlock(pos2, block1); }","title":"Home"},{"location":"#hlf-documentation","text":"HLF is a high level programming language which compiled (technically transpiled) to McFunction (Minecraft Datapacks). Here is an example script written in HLF: // The load function is ran when the datapack is loaded void load(){ say(\"let's say something 5 times:\"); for(int i = 0; i < 5; i++){ if(i == 3){ say(\"Let's just skip the 3\"); continue; } say($\"Now, we're at {i}\"); // You can use string interpolation (inserting values into strings) like this } // let's calculate some stuff say($\"2-8^2*3 = {2-pow(8, 2)*3}\"); // Swap two blocks: Vector pos1 = Vector(127, 65, 2); Vector pos2 = Vector(126, 65, 2); BlockType block1 = getBlock(pos1); BlockType block2 = getBlock(pos2); setBlock(pos1, block2); setBlock(pos2, block1); }","title":"HLF documentation"},{"location":"FunctionReference/","text":"Function reference say() The say function prints a value to the chat. Example: say(\"Hello world\")","title":"Function reference"},{"location":"FunctionReference/#function-reference","text":"","title":"Function reference"},{"location":"FunctionReference/#say","text":"The say function prints a value to the chat. Example: say(\"Hello world\")","title":"say()"},{"location":"functionDefinitions/","text":"Function definitions You can define functions like in other languages like this: void myFunction() { say(\"My function was called!\"); } Parameters HLF supports function parameters you can define them like this: void yeet(Entity target, float amount) { target.Motion = Vector(0, amount, 0); } Calling custom functions You can call custom function just like any other functions: yeet(@e[type=sheep, limit=1], 2); Calling custom functions from McFunction When transpiled, custom functions become regular McFunction functions meaning you can call them using the /function command. However, to run a function with parameters from McFunction, you would need to assign them in the data storage. As of now, there are no tools implemented to let you see which parameters correspond to which data paths. Limitations As of now, HLF does not support return values from custom functions. This means that a function can only be defined as void .","title":"Function Definitions"},{"location":"functionDefinitions/#function-definitions","text":"You can define functions like in other languages like this: void myFunction() { say(\"My function was called!\"); }","title":"Function definitions"},{"location":"functionDefinitions/#parameters","text":"HLF supports function parameters you can define them like this: void yeet(Entity target, float amount) { target.Motion = Vector(0, amount, 0); }","title":"Parameters"},{"location":"functionDefinitions/#calling-custom-functions","text":"You can call custom function just like any other functions: yeet(@e[type=sheep, limit=1], 2);","title":"Calling custom functions"},{"location":"functionDefinitions/#calling-custom-functions-from-mcfunction","text":"When transpiled, custom functions become regular McFunction functions meaning you can call them using the /function command. However, to run a function with parameters from McFunction, you would need to assign them in the data storage. As of now, there are no tools implemented to let you see which parameters correspond to which data paths.","title":"Calling custom functions from McFunction"},{"location":"functionDefinitions/#limitations","text":"As of now, HLF does not support return values from custom functions. This means that a function can only be defined as void .","title":"Limitations"},{"location":"loops/","text":"Loops There are while and for loops in HLF. While loops You can write while loops like this: while(condition){ // code here is ran as long as the condition evaluates to true } For loops You can write for-loops like this: for(<initializer>;<condition>;<increment>) { // loops content goes here } When the loop is run, the initializer is run first, it is typically used to initialize a counter variable. After that the loops begins and runs like this: Condition is evaluated, loops stops if the condition is false Loops content is run Increment statement is run An example of a classic usage of a for loop is: for(int i = 0; i < 5; i++) { say(i); } This code would print all numbers from 0 to 4 to the chat Limitations Loops are limited by the maxCommandChainLength -gamerule. By default, it is set to 10000000 when a datapack loads. This is to prevent unintuitive behaviour. This (hopefully) is a temporary solution.","title":"Loops"},{"location":"loops/#loops","text":"There are while and for loops in HLF.","title":"Loops"},{"location":"loops/#while-loops","text":"You can write while loops like this: while(condition){ // code here is ran as long as the condition evaluates to true }","title":"While loops"},{"location":"loops/#for-loops","text":"You can write for-loops like this: for(<initializer>;<condition>;<increment>) { // loops content goes here } When the loop is run, the initializer is run first, it is typically used to initialize a counter variable. After that the loops begins and runs like this: Condition is evaluated, loops stops if the condition is false Loops content is run Increment statement is run An example of a classic usage of a for loop is: for(int i = 0; i < 5; i++) { say(i); } This code would print all numbers from 0 to 4 to the chat","title":"For loops"},{"location":"loops/#limitations","text":"Loops are limited by the maxCommandChainLength -gamerule. By default, it is set to 10000000 when a datapack loads. This is to prevent unintuitive behaviour. This (hopefully) is a temporary solution.","title":"Limitations"},{"location":"raycasting/","text":"Raycasting HLF provides functions to easily perform raycasting. Raycasting for blocks You can raycast for blocks using the raycast() functions. It takes the ray-origin, the ray-direction and the maxSteps as parameters. The function returns the position where the ray hit a block. If the ray didn't hit anything, the function will return the position where the ray stopped. Example: Vector origin = Vector(0, 64, 0); Vector direction = Vector(0.5, -0.5, 0); Vector hit = raycast(origin, direction, 1000); // replaces the block where the ray hit the ground with a restone_block setBlock(hit, BlockType(\"restone_block\")); Raycasting for entities You can raycast for entities using the raycastForEntity() functions. It takes the ray-origin, the ray-direction and the maxSteps as parameters as well. The function returns a reference to the entity hit by the ray. If the ray didn't hit an entity, it will return an empty entity . There is currently no way of telling if the entity is empty . (Ik, this should be fixed asap) Example: Vector origin = Vector(0, 64, 0); Vector direction = Vector(0.5, -0.5, 0); Entity hit = raycastForEntity(origin, direction, 1000); // kills the entity hit by the ray kill(hit); Raycasting from the players cross-hare Raycasting from the players perspective is luckily very easy thanks to the Forward property of the Entity -Type. The Forward -property returns a directional Vector specifying the way an entity is looking. Example: // Make sure to offset the ray-origin because the players position is at their feet, not their eyes. Vector origin = @p.Positon + Vector(0, 1.7, 0); Vector direction = @p.Forward; Vector hit = raycast(origin, direction, 1000); // replaces the block where the player is looking with a restone_block setBlock(hit, BlockType(\"restone_block\")); Max steps The maxSteps-value is used to stop the raycast after a certain amount of iterations. The default stepSize is 0.1 blocks. This means that the max-length of a ray with a max-steps value of 1000 is 0.1 blocks * 1000 = 100 blocks.","title":"Raycasting"},{"location":"raycasting/#raycasting","text":"HLF provides functions to easily perform raycasting.","title":"Raycasting"},{"location":"raycasting/#raycasting-for-blocks","text":"You can raycast for blocks using the raycast() functions. It takes the ray-origin, the ray-direction and the maxSteps as parameters. The function returns the position where the ray hit a block. If the ray didn't hit anything, the function will return the position where the ray stopped. Example: Vector origin = Vector(0, 64, 0); Vector direction = Vector(0.5, -0.5, 0); Vector hit = raycast(origin, direction, 1000); // replaces the block where the ray hit the ground with a restone_block setBlock(hit, BlockType(\"restone_block\"));","title":"Raycasting for blocks"},{"location":"raycasting/#raycasting-for-entities","text":"You can raycast for entities using the raycastForEntity() functions. It takes the ray-origin, the ray-direction and the maxSteps as parameters as well. The function returns a reference to the entity hit by the ray. If the ray didn't hit an entity, it will return an empty entity . There is currently no way of telling if the entity is empty . (Ik, this should be fixed asap) Example: Vector origin = Vector(0, 64, 0); Vector direction = Vector(0.5, -0.5, 0); Entity hit = raycastForEntity(origin, direction, 1000); // kills the entity hit by the ray kill(hit);","title":"Raycasting for entities"},{"location":"raycasting/#raycasting-from-the-players-cross-hare","text":"Raycasting from the players perspective is luckily very easy thanks to the Forward property of the Entity -Type. The Forward -property returns a directional Vector specifying the way an entity is looking. Example: // Make sure to offset the ray-origin because the players position is at their feet, not their eyes. Vector origin = @p.Positon + Vector(0, 1.7, 0); Vector direction = @p.Forward; Vector hit = raycast(origin, direction, 1000); // replaces the block where the player is looking with a restone_block setBlock(hit, BlockType(\"restone_block\"));","title":"Raycasting from the players cross-hare"},{"location":"raycasting/#max-steps","text":"The maxSteps-value is used to stop the raycast after a certain amount of iterations. The default stepSize is 0.1 blocks. This means that the max-length of a ray with a max-steps value of 1000 is 0.1 blocks * 1000 = 100 blocks.","title":"Max steps"},{"location":"stringInterpolation/","text":"String Interpolation Sometimes, you might want to write a value to the chat but annotate what it is. In these cases, you can use string interpolation to interpolate a value into a string. Example: int a = 25; say($\"A has a value of {a}\"); The inserted value doesn't have to a variable. You can use any expression you like: say($\"2^(2+3*2) {pow(2, 2+3*2)}\"); You can also interpolate multiple values into a string: int r = 2; float pi = 3.14; say($\"The circle has a radius of {r}, so the area of the circle is {pi*pow(r, 2)}\");","title":"String Interpolation"},{"location":"stringInterpolation/#string-interpolation","text":"Sometimes, you might want to write a value to the chat but annotate what it is. In these cases, you can use string interpolation to interpolate a value into a string. Example: int a = 25; say($\"A has a value of {a}\"); The inserted value doesn't have to a variable. You can use any expression you like: say($\"2^(2+3*2) {pow(2, 2+3*2)}\"); You can also interpolate multiple values into a string: int r = 2; float pi = 3.14; say($\"The circle has a radius of {r}, so the area of the circle is {pi*pow(r, 2)}\");","title":"String Interpolation"},{"location":"structs/","text":"Structs You can define custom data types using structs. A struct is essentially a compound of other values. You can define a struct like this: struct MyStructType { string someStringValue; int someIntValue; int anotherIntValue; } As of now, default values for struct fields are unfortunately not supported. Instantiating struct types You can instantiate a struct using the new -keyword: MyStructType myCustomObject = new MyStructType(); When you have instantiated your struct, you can access and assign its fields like this: // Assinging struct fields: myCustomObject.someStringValue = \"This is stored in your struct\"; myCustomObject.someIntValue = 0; myCustomObject.anotherIntValue = 5; // Getting values froom struct fields say(myCustomObject.anotherIntValue); Limitations Unfortunately, you currently can't store Entity s or BlockType s in structs. This has to do with how structs are stored as nbt while BlockTypes and Entities are stored differently.","title":"Structs"},{"location":"structs/#structs","text":"You can define custom data types using structs. A struct is essentially a compound of other values. You can define a struct like this: struct MyStructType { string someStringValue; int someIntValue; int anotherIntValue; } As of now, default values for struct fields are unfortunately not supported.","title":"Structs"},{"location":"structs/#instantiating-struct-types","text":"You can instantiate a struct using the new -keyword: MyStructType myCustomObject = new MyStructType(); When you have instantiated your struct, you can access and assign its fields like this: // Assinging struct fields: myCustomObject.someStringValue = \"This is stored in your struct\"; myCustomObject.someIntValue = 0; myCustomObject.anotherIntValue = 5; // Getting values froom struct fields say(myCustomObject.anotherIntValue);","title":"Instantiating struct types"},{"location":"structs/#limitations","text":"Unfortunately, you currently can't store Entity s or BlockType s in structs. This has to do with how structs are stored as nbt while BlockTypes and Entities are stored differently.","title":"Limitations"},{"location":"types/","text":"Types HLF's type system allows you to pass values of a host of different types around. Builtin types are: Vector : A 3d-vector BlockType : A type of block Entity : A single entity in the world string : A character sequence int : An integer value float : A floating-point value. ( Unfortunately as of now, all float-operations are actually fixed-point operations ) See also Defining custom types","title":"Types"},{"location":"types/#types","text":"HLF's type system allows you to pass values of a host of different types around. Builtin types are: Vector : A 3d-vector BlockType : A type of block Entity : A single entity in the world string : A character sequence int : An integer value float : A floating-point value. ( Unfortunately as of now, all float-operations are actually fixed-point operations )","title":"Types"},{"location":"types/#see-also","text":"Defining custom types","title":"See also"},{"location":"variables/","text":"Variables Variables can be defined like in other C-style languages: <VariableType> <variableName> = <initialValue>; An example would be: int a = 16; Type system Since HLF is statically-typed, a variable must be assigned a datatype when it is declared. This datatype must not change during execution. Variables can be of any type that is not a compile-time-constant type. See Types Type inference In case you don't want to write the correct datatype everytime you declare a variable, you can let the transpiler infer its type from the initial value. To do this, declare a variable using the var or val keywords. var block = BlockType(\"stone\"); You can make a variable immutable by using the val -keyword: val i = 16; i = 14; // This will throw an error at compile-time","title":"Variables"},{"location":"variables/#variables","text":"Variables can be defined like in other C-style languages: <VariableType> <variableName> = <initialValue>; An example would be: int a = 16;","title":"Variables"},{"location":"variables/#type-system","text":"Since HLF is statically-typed, a variable must be assigned a datatype when it is declared. This datatype must not change during execution. Variables can be of any type that is not a compile-time-constant type. See Types","title":"Type system"},{"location":"variables/#type-inference","text":"In case you don't want to write the correct datatype everytime you declare a variable, you can let the transpiler infer its type from the initial value. To do this, declare a variable using the var or val keywords. var block = BlockType(\"stone\"); You can make a variable immutable by using the val -keyword: val i = 16; i = 14; // This will throw an error at compile-time","title":"Type inference"},{"location":"workingWithEntities/","text":"Working with entities The Entity -Datatype allows you to store references to entities in variables. Selectors To get an entity from the game-world, you can use a selector: Entity randomSheep = @e[type=sheep, sort=random, limit=1]; However, make sure, your selector can only return one entity (by using a limit=1 clause) The transpiler will complain otherwise. Summoning entities You can also create entities yourself using the summon function: Entity notSoRandomSheep = summon(\"sheep\"); When summoning an entity, it will be at the coordinates 0 0 0 by default. Make sure to place it somewhere logical my assigning its Position property: notSoRandomSheep.Position = Vector(0, 63, 0); Owned entities When you summon an entity from HLF, it is considered to be \"owned\" by your datapack. If you want your entity to be removed when your datapack is reloaded, you can all the killOwned() function to kill all entities owned by HLF: void main(){ // Do this in your main function killOwned(); }","title":"Working with Entities"},{"location":"workingWithEntities/#working-with-entities","text":"The Entity -Datatype allows you to store references to entities in variables.","title":"Working with entities"},{"location":"workingWithEntities/#selectors","text":"To get an entity from the game-world, you can use a selector: Entity randomSheep = @e[type=sheep, sort=random, limit=1]; However, make sure, your selector can only return one entity (by using a limit=1 clause) The transpiler will complain otherwise.","title":"Selectors"},{"location":"workingWithEntities/#summoning-entities","text":"You can also create entities yourself using the summon function: Entity notSoRandomSheep = summon(\"sheep\"); When summoning an entity, it will be at the coordinates 0 0 0 by default. Make sure to place it somewhere logical my assigning its Position property: notSoRandomSheep.Position = Vector(0, 63, 0);","title":"Summoning entities"},{"location":"workingWithEntities/#owned-entities","text":"When you summon an entity from HLF, it is considered to be \"owned\" by your datapack. If you want your entity to be removed when your datapack is reloaded, you can all the killOwned() function to kill all entities owned by HLF: void main(){ // Do this in your main function killOwned(); }","title":"Owned entities"}]}